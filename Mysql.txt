# Mysql

## Content
* Introduction

## Intro
Mysql architecture

![](Mysql%20Architecture.png)

### Components
* GUI
* Connectors
	* Native C API
	* JDBC
	* ODBC
	* …
* MySQL Server
	* Connection Pool
		* Authentication,
		* Thread reuse
		* Connection limits
		* Check memory
		* Caches
	* Mgmt services & Utilities
		* Backup & Recovery, security, replication, cluster administration, configuration, migration, metadata
	* SQL Interfaces
		* DML, DDL, Stored Procedures, views, Triggers, etc.
	* Parser
		* Query Translation, object privileges
	* Optimizer
		* Access Paths, Statistics
	* Caches * Buffers
		* Global & Engine specific caches & buffer
	* **Pluggable Storage engines**
		* Memory, Index & Storage mgmt
		* Types
			* InnoDB
			* MyISAM
			* NDB
			* Archive
			* Memory
			* …
	* File systems
		* NFTS, UFS, EXT2/3, NFS, SAN, NAS
	* Files & logs
		* Redo, undo, data, index, binary, error, query,slow

How does sql work
* datadir - data storage directory
* read the file from disk into memory
* CPU load the data in the memory to filter the data with the condition (WHERE)

局部性原理
* 从磁盘中取数据时，会把相邻数据也放入memory，下次想取数据，大概率会取相邻数据，直接从内存中取
* 取多少，一页数据， 4KB
* innodb_page_size ： 16384 B= 16 KB

### Data Structure
Page 
Structure
* File Header
* Page Header
* Infimun + Supremum records
* Page data space
	* **User Records**
	* **Free space**
* Page Directory
* File Trailor

Row 
Row format
* Compact
	* 变长字段长度列表 (varchar, VARBINARY, TEXT, BLOB), which record is varchar (M), save the M, 
	* NULL flag
	* Header info
	* COLUMN 1 data
	* Column 2 data
	* …
* Dynamic
* Redundant
* Compressed
```
CREATE TABLE TABLE_NAME ROW_FORMAT= FORMAT_NAME
ALTER TABLE TABLE_NAME ROW_FORMAT=FORMAT_NAME
```
Varchar(65535)
InnoDB, ROW SIZE = 65535 byte
Page size = 16KB = 16384 byte
**Row overflow (row size > page size)**
1. Row data + next page address
2. Store page addresses in first page (index)

MyISAM vs InnoDB
MyISAM (堆表）
* SELECT ORDER same as insert order

InnoDB（聚集 主键索引， Index）
* rows are ordered by the pk
* next_record to save the next record address, sort by pk, better performance for query
* page directory, group the rows, put the pk - address pair in the page dir, better performance for query/insert, search the page dir first then go to the row group.
* each page has size limit, save table data in different pages, in order to search, use a page to save the page data, (directory page save the key-value pair : pk-page address)
* B+ tree
	* leaf node : store data
	* Non-leaf node : pk+pointer(address)
* No pk, see if there’s unique column, otherwise it’s generate a row ID
* don’t prefer uuid to be the pk
* Initial page is changing with adding of pages
	* so MySQL, with copy the initial page and put the copied one under the initial page, so that the memory can cache the initial page in the memory for better performance.

Non-pk index(multiple column, 辅助索引)
```
Create table t1 (
A int primary key,
B int not null,
C int,
D int,
E varchar(20)
) engine=InnoDB
// create index on multiple column
Create index idx_t1_bcd on t1(b,c,d);
```

* compare the values in the order of b->c->d
* insert record in the linked list of leaf node of B+ tree
* The key-value pair in the dir page, the value is  combination of multiple columns索引值
* 辅助索引，innodb，for Leaf node, key-value pair is combination index value (multiple columns) and the primary key of record, to avoid redundant data, Then go to the primary key index tree to find the record主键回表


```
Explain select * from t1 where b =1 and c = 1 and d = 1;
//find the index used by the table

```

Explain keyword
	* type
		* all, 全表扫描
		* Ref, 辅助索引+回表
	* possible_key
		* possible index we can use
	* Key
		* real used index

全表扫描优于辅助索引
```
Where b > 0 
//辅助索引找到的pk数量非常大>80%，不如直接取主键
```
	
Collation, 定义字符集比较规则
mysql，utf-8， 0-3 byte， utf-8mb4, 0-4 byte

Some sql queries can use index, some cannot

什么时候可以用到index

* 最左前缀原则
	辅助索引，不一定要提供所有的col值，但是最左侧的col的值一定要有
	like keyword，
		* b like ‘%101%’ 不行
		* b like ‘101%‘ 可以

* url like ’%com‘， 可以倒序存储，查询可用index
* 匹配范围值，
	* （b>1 and b<2000）
		* 用index找，b=1, b=8, 找 之间的数据集
	* b > 1 and c > 1
		* b = 1, 找到
		* c > 1, 不能用到索引

排序（order by)
```
Explain select b from t1 order by b, c, d
```

* index 已经排好序，可以直接返回

```
Explain select b from t1 where b =1 order by c,d
```
* 最左前缀原则，可以用index

分组 Group by
* 和order by 类似

NULL
NULL值最小

### 事务
* 事务，transaction
* 事务隔离级别，每种隔离级别分别什么现象
* 锁是什么，mysql有哪些锁

ACID
* Atomicity原子性
	*
* Consistency一致性
	*
* Isolation隔离性
	*
* Durability持久性


Transaction
* autocommit 
```
Show variables like ‘autocommit’


```
* manual commit
```
// start a transaction
Begin;

Update t1 set c = 3 where a = 1;

Commit; // end transaction

//rollback;

```

隐式提交
DDL ： create, alter, drop， LOCK，ANALYZE table 去修改数据库对象，会隐式提交前边语句的transaction

保存点
分段rollback
```
SAVEPOINT p1；
ROLLBACK TO p1;
```

### Isolation level
* read uncommitted 读未提交
	* 一个事务可以读到其他事务没有提交的数据，出现脏读 dirty read
```
Set session transaction isolation level read uncomitted
```
* read committed 读已提交
	* 一个事务只能读到另一个已经提交的事务修改的数据，其他事务对该数据进行一次修改并提交后，该事务都能查询到最新值，会出现
	* 不可重复-读（先后读出来的数据不一样， update）
	* 幻读（一个事务按条件查询，另一个事务insert复合条件的record，原先事务再次查询，能把另一个事务插入的record也读出来）

* repeatable read (default 可重复读）
	* 一个事务读过某条record，即使其他事务update value并提交，该事务再读出该record，读到的依旧是一样的值，而不会读到不同数据，这就是可重复读，但是还有会有幻读

* serialiable （串行化）
	* 上面三种iosalation level允许对一条record同时进行读读，读写，写读并发操作，可以使用serializable，对同一条record都是串行读，不会有脏读，幻读
	* Update/insert will be blocked if another transaction is working on write


* read uncommitted, 出现 dirty/unrepeatable/

| isolation level |dirty read  | unrepeatable read | phantom read |
|:--|:--|:--|:--|
| read uncommitted | x | x | x |
| read committed |  | x | x |
| repeatable read |  |  | x |
| serializable |  |  |  |

phantom read
* Read committed，
* Repeatable read
* Serializable
上述为SQL标准定义，不同数据库可以有不同实现，Mysql在repeatable read 下，可以禁止幻读phantom read问题

#### Isolation level implementation
记录真实数据，出自定义列，有三个隐藏列

| name | 必须 | 占用空间 | 描述 |
|:--|:--|:--|:--|
| row_id | no | 6byte | 唯一标志一条record |
| trx_id | yes | 6byte | transaction id|
| roll_pointer | yes | 7 byte | roll back pointer |

* read uncommitted
	* no limit
* read committed
	
	* Transaction_id 保存最近修改record的事务id
	* roll_pointer 指向之前版本（版本链，存放undolog）
	* 只读版本链上transaction_id相同的record的值，
	* ReadView，
		* read uncommitted，直接读取最新版本
		* serializable，加锁访问
		* read committed，repeatable read
			* 版本链 + readview（判断那个版本是当前事务可见的）

		* select， 生成readview，有4个主要内容
			* m_ids : 生成readview时活跃的事务id列表（未提交）查询版本链，对比m_ids,找到提交的
			* Min_trx_id ： 活跃的读写事务最小事务id，
			* Max_trx_id ： 系统应该分配给下一个事务的id
			* Creator_trx_id ： 生成该readview事务的id

	* repeatable read
		* 复用 第一次生成的readview，保存有当时所有的活跃trx_ids, 所以包含结束的trx_id,和之前一样，实现可重复读
		* 通过gap lock实现phantom read

#### MVCC (Multi-version concurrency control)
MVCC, 多版本并发控制，
* 在使用read committed, repeatable read transaction时，执行普通select操作访问record的版本链过程中，可使不同事务并发操作，提高性能（避免使用锁block）
* read committed vs repeatable read
	* 生成readview时间不同
		* read committed在每次进行select操作会生成readview
		* repeatable read 只在第一次select时生成readview，之后复用
* undolog，存储逻辑链，如何rollback


### Lock
Optimistic Lock
* a strategy where you read a record, **take note of a version number** (other methods to do this involves dates, time stamps or checksums/hash),
* Before your write the record back, **check that the version hasn’t changed**
* When you write the record back you filter the   Update on the version to make sure it’s atomic.
* If the record is dirty, aborting the transaction and user can restart it
* **Usage Scenario : Read > write **
* pro : incurs overhead when there’s a conflict
* con : better performance

Pessimistic Lock
* when you lock the record for exclusive use until you have finished with it.
* requirement :
	* either use a direct connection to db 
	* Or an externally available transaction_id that can be used independently of the connection : (open the transaction with the trx_id and then reconnect using that ID, the DBMS maintains the locks and allows you to pick up the session back up through the trx_id)
* **usage scenario : write > read, know there will be many conflicts ** 
* pro : Has better integrity than optimistic lock, 
* Con : should be careful with the deadlocks




